<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode-905. 按奇偶校验排序数组 | Sort Array By Parity]]></title>
    <url>%2Fleetcode-905-%E6%8C%89%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-sort-array-by-parity.html</url>
    <content type="text"><![CDATA[题目链接 题目给定一个非负整数数组 A，返回一个由 A 的所有偶数元素组成的数组，后面跟 A 的所有奇数元素。 你可以返回满足此条件的任何数组作为答案。 示例： 123输入：[3,1,2,4]输出：[2,4,3,1]输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。 提示： 1 &lt;= A.length &lt;= 5000 0 &lt;= A[i] &lt;= 5000 解答分析由于没有多余的要求，只需要建立一个数组B，通过循环对A的元素进行奇偶校验，然后根据元素为奇数或者偶数，分别插入到数组的尾部或者头部即可。 另外一种方式，就是通过while循环，直接对数组A进行原地修改。 最后，还可以利用python的sort()函数，对数组A进行排序。 解答方式一：12345678910111213141516class Solution:"""方式一：直接根据元素的奇偶，插入到数组B的首部或尾部即可""" def sortArrayByParity(self, A): """ :type A: List[int] :rtype: List[int] """ B = [] for i in A: if i % 2 == 0: B.insert(0,i) else: B.insert(len(B),i) return B 方式二：12345678910111213141516171819class Solution:"""方法二: 使用while,原地修改A数组,将数组中奇数元素移动到数组末端""" def sortArrayByParity(self, A): """ :type A: List[int] :rtype: List[int] """ x = len(A) i = 0 while x&gt;0: if A[i] % 2 != 0: A.append(A.pop(i)) x-=1 else: x -= 1 i += 1 return A 方式三：12345678910class Solution: def sortArrayByParity(self, A): """ :type A: List[int] :rtype: List[int] 方法三：使用sort()方法 """ A.sort(key=lambda num:num%2) return A # return sorted(A,key=lambda num:num%2) 这里涉及两个知识点： list.sort() 匿名函数（lambda） 扩展解题中的问题知识点:1. list.sort()参考： 官方文档：https://docs.python.org/3/howto/sorting.htmlRUNOOB：http://www.runoob.com/python/att-list-sort.html廖雪峰Python教程： https://www.liaoxuefeng.com/wiki/… 1list.sort(cmp=None, key=None, reverse=False) 一些基础知识： list.sort() 永久排序， sorted(list) 非永久排序。 list.sort() 只能用于数组，而 sorted() 可以用于所有迭代类型。 12 &gt;&gt;&gt; sorted(&#123;1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'&#125;)[1, 2, 3, 4, 5] reverse参数，控制排序的循序，默认为false。当reverse=True时，为倒序排序。 key 参数的功能 sort() 和 sorted() 都拥有的一个 key 参数，通过指定在进行比较之前对每个列表元素调用的函数，以实现自定义排序。 通过key参数，可以实现例如： 以一个复合列表中元素的第i个元素的值为依据进行排序 以忽略大小写的方式，对字符串进行排序 比较数组元素绝对值的大小 本题中，对数组进行奇偶校验排序 …… 下面是几个例子： 例1：忽略大小写排序（引用自官方文档） 12&gt;&gt;&gt; sorted("This is a test string from Andrew".split(), key=str.lower)['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] 通过指定str.lower 使得在排序前，先将列表中的元素转换为了小写。 例2：对数组绝对值进行排序（引用自廖旭峰的python教程） 12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36] 例3：对一个保存学生信息的列表，按照学生年龄进行排序。（引用自官方文档） 每个学生信息存储在一个子列表中 1234567&gt;&gt;&gt; student_tuples = [... ('john', 'A', 15),... ('jane', 'B', 12),... ('dave', 'B', 10),... ]&gt;&gt;&gt; sorted(student_tuples, key=lambda student: student[2]) # sort by age[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 每个学生信息存储在学生对象中： 1234567&gt;&gt;&gt; class Student:... def __init__(self, name, grade, age):... self.name = name... self.grade = grade... self.age = age... def __repr__(self):... return repr((self.name, self.grade, self.age)) 1234567&gt;&gt;&gt; student_objects = [... Student('john', 'A', 15),... Student('jane', 'B', 12),... Student('dave', 'B', 10),... ]&gt;&gt;&gt; sorted(student_objects, key=lambda student: student.age) # sort by age[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 排序稳定性和复合排序排序首先保证稳定，当多个元素（每个元素具有多个值）用于比较的项目的值相同时，会保留它们的原始顺序。这个有点可以在让python方便的进行复合排序。 1234# 先对年龄进行升序排序，然后再对成绩进行降序排序。&gt;&gt;&gt; s = sorted(student_objects, key=attrgetter('age')) # sort on secondary key&gt;&gt;&gt; sorted(s, key=attrgetter('grade'), reverse=True) # now sort on primary key, descending[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 例子来自官方文档 python2中使用的cmp参数 这部分的官方文档链接：https://docs.python.org/3/howto/sorting.html#the-old-way-using-the-cmp-parameter python2.x版本，提供了cmp参数，提供用于进行比较的相关功能。简单来书就是建立一个比较函数，通过返回值（大于0的数，等于0，小于0的数）来控制排序。引用官方文档中给出的比较数字大小的例子 按照正序排列数组： 1234&gt;&gt;&gt; def numeric_compare(x, y):... return x - y&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=numeric_compare) [1, 2, 3, 4, 5] 按照倒序排列数组： 1234&gt;&gt;&gt; def reverse_numeric(x, y):... return y - x&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=reverse_numeric) [5, 4, 3, 2, 1] 在python3中cmp已经被完全移除了，如果取而代之的是key参数。如果需要将python2的代码转到python3，只需使用下面的包装器，对适用于cmp的函数进行处理，使其适用于key即可： 123456789101112131415161718def cmp_to_key(mycmp): 'Convert a cmp= function into a key= function' class K: def __init__(self, obj, *args): self.obj = obj def __lt__(self, other): return mycmp(self.obj, other.obj) &lt; 0 def __gt__(self, other): return mycmp(self.obj, other.obj) &gt; 0 def __eq__(self, other): return mycmp(self.obj, other.obj) == 0 def __le__(self, other): return mycmp(self.obj, other.obj) &lt;= 0 def __ge__(self, other): return mycmp(self.obj, other.obj) &gt;= 0 def __ne__(self, other): return mycmp(self.obj, other.obj) != 0 return K 要转换为key方法，只需要对原来的函数进行包装即可： 12&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))[5, 4, 3, 2, 1] 在python3.2中，functools.cmp_to_key()函数已经添加到了基础库的 functools 模块中。 12345678910import functoolsdef numeric_compare(x, y): return x - ynums = [2, 3, 1, 4, 5]print(sorted(nums, key=functools.cmp_to_key(numeric_compare)))---结果---[1, 2, 3, 4, 5] 2. 匿名函数：官方文档：https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions 直接用一个例子来解释： 12A = [3,1,2,4]print(sorted(A,key=lambda num:num%2)) 就相当于： 1234def evenNumber(num): return num % 2print(sorted(A, key=evenNumber)) 思考需要跟多的去阅读相关语言的文档，解题中遇到的很多问题，在对文档有了更多的了解后，会更容易解决。]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Python Tips</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Easy</tag>
        <tag>Python 排序函数 list.sort()</tag>
        <tag>Python 匿名函数 lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配合使用MWeb进行Blog编写]]></title>
    <url>%2F%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8mweb%E8%BF%9B%E8%A1%8Cblog%E7%BC%96%E5%86%99.html</url>
    <content type="text"><![CDATA[目前用来作为功能测试，以后会进行归纳总结 测试更新1 插入图片设置 路径设定为 images/post绝对路径（这个绝对与相对是基于引入文件夹的，如果引入的是存储Blog资源的文件夹(像我目前这样)，就设定为 绝对路径；如果引入的是整个Blog项目(例如 NSDingFan.github.io), 就使用相对路径）]]></content>
      <categories>
        <category>基于 Heox + NexT 的 blog 搭建</category>
      </categories>
      <tags>
        <tag>blog 搭建</tag>
        <tag>MWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[会对"本地搜索"功能出现影响的文本内容]]></title>
    <url>%2F%E4%BC%9A%E5%AF%B9-%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2-%E5%8A%9F%E8%83%BD%E5%87%BA%E7%8E%B0%E5%BD%B1%E5%93%8D%E7%9A%84%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9.html</url>
    <content type="text"><![CDATA[Error 更新文章后, 搜索功能一直卡在加载状态, 切换到 nsdf.top/search.xml 页面,发现有以上错误提示. 问题语句: 有问题的语句: 点击图片可以下载这个文件 没问题的语句: 在打开一个新的项目文件夹时 就需要重新配置 launch.json 中的 cwd 参数 分析:问题在于空格, 在有问题文本中,存在着编码错误的空格,如果你尝试删除这些空格,会发现在有两处空格位置需要删除两次才会消失, 这两个位置就是问题产生的原因. 解决方式 寻找一种可以重新将文本编码的方式 或者把有问题的文件改掉,参考: http://www.itfanr.cc/2017/11/24/resolve-hexo-blog-search-exception/ 使用Sublime或者vim,都可以很明显的看出问题在哪]]></content>
      <categories>
        <category>基于 Heox + NexT 的 blog 搭建</category>
      </categories>
      <tags>
        <tag>blog 搭建</tag>
        <tag>hexo-local-search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog搭建踩坑指南]]></title>
    <url>%2Fblog%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97.html</url>
    <content type="text"><![CDATA[看，前面有个坑。 ─=≡Σ(((つ•̀ω•́)つ))]]></content>
      <categories>
        <category>基于 Heox + NexT 的 blog 搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog 搭建</tag>
        <tag>git</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-122.买卖股票的最佳时机 II | Best Time to Buy and Sell Stock II]]></title>
    <url>%2Fleetcode-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii-best-time-to-buy-and-sell-stock-ii.html</url>
    <content type="text"><![CDATA[题目链接 题目给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解答分析从题目中分析，要求只能保留一只股票，并且尽可能完成多的交易。 于是我开始尝试从从第一个低于第二天价格的位置买入，然后在第一个高于此价格的位置卖出，然后再从下一个低于后续价格的位置买入，然后在最近的高于此价格位置卖出。经过计算，我发现按照这种方式，所有的买入和卖出操作都是发生在相邻元素的，也就是列表的 i和i+1位置。并且在计算了实例的三个用例后，结果符合预期。同时，这也符合 贪心算法 的思路。 进而得出结论，只要计算列表中所有相邻元素的差值，最大收益即为所有差值大于0的结果的和。 从列表长度方面分析，当列表为空，或者只有一个元素的时候，不满足买入卖出条件，所以可以在计算时先行排除。 方式一123456789101112131415161718192021class Solution1: """ 首先判断 prices长度是否小于2, 然后循环结算列表 i+1 与 i 的差, 并将大于0的结果累加。 最后返回累加结果,即为最大收益 """ def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ max_profit = 0 if len(prices) &lt; 2: return max_profit for i in range(len(prices) - 1): profit = prices[i + 1] - prices[i] if profit &gt; 0: max_profit += profit return max_profit 时间复杂度：O(N) ， 空间复杂度： O(1) 方式二只是写了一个列表解析^jiexi，一行完成。 实际性能不如方式一。 123456789101112class Solution2:"""解题思路与方式一相同，列表 i+1 与 i 元素相减，并将大于0的结果相加。只是改用了列表解析的方式，来写成一行。 """ def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ return int((sum(list((prices[i + 1] - prices[i]) + abs(prices[i + 1] - prices[i])for i in range(len(prices) - 1)))) / 2) 时间复杂度：O(N)，空间复杂度：O(N) 思考由于是刚开始接触算法题，最开始看到这道题的时候有些摸不着头脑。不知道从哪里入手，比如怎么找出差值最大的和，是先判断间隔为1的差值，在判断间隔为2的差值…但是沉下心来，在纸上进行一些尝试后，找出适用于用例的计算方式，很快就找到了这个规律，直接找出相邻的差值即可。然后写成代码进行验证，符合预期。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>贪心算法</tag>
        <tag>列表</tag>
        <tag>列表解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-219.存在重复元素 II | Contains Duplicate II]]></title>
    <url>%2Fleetcode-219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii-contains-duplicate-ii.html</url>
    <content type="text"><![CDATA[题目链接 题目给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1: 12输入: nums = [1,2,3,1], k = 3输出: true 示例 2: 12输入: nums = [1,0,1,1], k = 1输出: true 示例 3: 12输入: nums = [1,2,3,1,2,3], k = 2输出: false 解决方案思路这道题，可以直接使用一个长度为k的哈希表即可解决问题。哈希表中只会保存不重复的内容，所以通过循环，按顺序每次向哈希表中添加一个列表元素，判断哈希表长度是否增长：如果增长，就将最早加入哈希表的元素删除，以保持哈希表长度位k；如果长度不变，即找到了列表中满足重复且索引差的绝对值最大为k的元素，题目结束。 这就相当与在一条数字组成的轨道上放置的一个长度为k的方框，只要判断框框范围内是否有重复即可，而不需要从一开始就找到所有重复元素。 此外，还可以在程序开头，先行判断： 列表是否存在重复 列表长度是否超过k 补充：这道题也可以使用字典来实现类似哈希表的操作，用key存nums[i]的值,value 存 nums[i]的索引。每当发现重复元素时（if xx in dic），判断字典中对应key的 value值是与当前元素的索引值的差，如果符合!&gt;k 这个条件，即找到结果，反之则更新字典中key的value值。 方法一：通过set来解决问题 1234567891011121314151617181920212223242526272829303132class Solution: """ 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 """ # 需要使用 haseSet来解决问题 def containsNearbyDuplicate(self, nums, k): """ :type nums: List[int] :type k: int :rtype bool 使用hash set 来判断 k长度的窗口中有无重复的数字 """ # 判断nums为空的情况 if not nums: return False # 判断nums长度小于k的情况 if len(nums) &lt;= k: return len(nums) &gt; len(set(nums)) # 判断读取的前k个元素有无重复 hashset = set(nums[:k]) if len(hashset) &lt; k: return True # 循环判断,每次按顺序添加一个元素到set中,判断长度.如果为k,证明新加入的元素与set中的存在重复,条件成立. # 否则,就将set中最早加入的元素去掉, 由于set()后会改变原nums顺序,所以需要使用remove方法,按照添加顺序去除. 即nums[i-k] for i in range(k, len(nums)): hashset.add(nums[i]) if len(hashset) == k: return True else: hashset.remove(nums[i - k]) # 这里相当于去掉了nums的第一个元素,依次类推 return False 时间复杂度：O(N), 空间复杂度 O(1) beat 98.67 % 的 python3 方法二：通过使用字典来解决问题,用key存nums[i]的值,value寸nums[i]的索引 1234567891011121314151617class Solution: def containsNearbyDuplicate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: bool """ #利用字典存储数据，以便查询，key为数字，value为对应索引 dic = &#123;&#125; for index, value in enumerate(nums): if value in dic and index - dic[value] &lt;= k: return True else: dic[value] = index # Q: 如果发现重复的数字但是不满足k的条件,如何处理 # A: dic使用value作为key,所以只会保留一个数字最新的索引,不满足条件就会被覆盖 return False 时间复杂度：O(N), 空间复杂度 O(N) 思考：看到这道题时，首先想到的思路是分步进行操作： 判断列表是否存在重复元素 找出重复的元素，并返回set()后的结果 找出每个重复元素在列表中的所有位置的索引 判断这些索引之间的差，是否存在 不超过k的结果。我按照这个思路分块写出了代码后，逻辑没有任何问题，但是用时超出时间限制。 经过分析和梳理，发现自己把简单问题复杂化了，上面使用的这个set(),就可以直接解决问题。 在练习算法题的时候，如果自己安装逻辑方式的解法不满足题目要求，尝试多动手在本子上画一画，或者说进行一些空间想象，可能会找出更好的方案。例如这道题，其实就像一个数组轨道上加一个长度为k的方框这样的东西。不需要考虑方框外的情况，只要确认方框内的数组满足条件即可。 最开始，想的很复杂的解决方式：]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>列表</tag>
        <tag>哈希表</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过MarkDown编写blog进阶技巧]]></title>
    <url>%2F%E9%80%9A%E8%BF%87markdown%E7%BC%96%E5%86%99blog%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7.html</url>
    <content type="text"><![CDATA[在MarkDown中插入链接的一些技巧1. 直接添加链接1&lt;http://nsdf.top/&gt; http://nsdf.top/ 2. 一般的链接123丁帆的blog： [nsdf.top](http://nsdf.top/)丁帆的blog： [nsdf.top](http://nsdf.top/ "丁帆的博客") 丁帆的blog： nsdf.top 丁帆的blog： nsdf.top 3. 相对链接链接至自己blog中的其他文章等内容：12[个人博客搭建踩坑指南](/2018/08/18/一些推荐的文章/)[封面图片](/img/post_bg_apple_ad.jpg) 个人博客搭建踩坑指南 封面图片 注:此为Jekyll内容,待修改 4. 在图片中嵌入链接1[![apple-touch-icon](/images/post/blog-logo.png))](http://nsdf.top/) ) 注: 此功能在基于Jekyll的blog中为点击图片前往链接;在基于Heox+NexT的blog中,为点击图片下方链接跳转. !!!待修改 5. 在新标签中打开连接1[nsdf.top](http://nsdf.top/)&#123;:target=&quot;_blank&quot;&#125; nsdf.top{:target=”_blank”} 注: 在之前使用的基于Jekyll的Blog中,这个功能可用且需要. 在当前基于Heox+NexT的blog中,不需要这样写. 在MarkDown中插入视频在MarkDown中，只要使用 &lt;iframe&gt; 标签就可以方便的插入视频了。 关于 &lt;iframe&gt; 的更多信息： w3school-HTML-iframe 标签 下面的示例中，分别演示了插入 腾讯，优酷，YouTube，哔哩哔哩 这几个网站的视频的操作 示例：1. 腾讯视频 打开一个视频，点击下方分享按钮，然后复制通用代码 将复制的代码粘贴至MarkDown文件中。 这样就完成了。 1&lt;center&gt;&lt;iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=j0600cjxtp0&amp;tiny=0&amp;auto=0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt; 另外，如果需要视频居中显示，可能还需要（视blog而定）添加一个&lt;center&gt;标签。 最终效果如下： 2. 优酷 同样的，打开一个视频，点击分享，然后复制通用代码 将代码粘贴至MarkDown文件中。就完成了 1&lt;iframe height=498 width=510 src='http://player.youku.com/embed/XMTg0MTQ4NDk4OA==' frameborder=0 'allowfullscreen'&gt;&lt;/iframe&gt; 效果如下 我发现在我常用的Safari以及chrome浏览器中，无法识别优酷的这种写法。于是我将代码改为了下面的写法，主要是将 height,width,frameborder 的数值加上双引号，将src链接改为双引号，最后将allowfullscreen单引号去掉 1&lt;iframe height="498" width="510" src="http://player.youku.com/embed/XMTg0MTQ4NDk4OA==" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt; 3. YouTube 直接在视频上右击，选择复制嵌入代码，然后粘贴至MarkDown中即可。 效果如下 1&lt;iframe width=&quot;919&quot; height=&quot;525&quot; src=&quot;https://www.youtube.com/embed/LcGPI2tV2yY&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; allowfullscreen&gt;&lt;/iframe&gt; 4. 哔哩哔哩 基本流程也一样，具体看下面截图就好了。需要注意的是，哔哩哔哩复制来的嵌入代码的src 缺少 https:，我需要补上这个，链接才会恢复正常。同时，还需要添加窗口尺寸等设置。 具体操作： 在网站中复制嵌入代码： 修改复制到的嵌入代码： 原本的： 1&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=1031924&amp;cid=1494043&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt; 修改后: 1&lt;iframe width=&quot;640&quot; height=&quot;498&quot; src=&quot;https://player.bilibili.com/player.html?aid=1031924&amp;cid=1494043&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt; 效果]]></content>
      <categories>
        <category>基于 Heox + NexT 的 blog 搭建</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>iframe</tag>
        <tag>链接跳转</tag>
        <tag>图片链接</tag>
        <tag>blog技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode 中使用 Python 异常报错 FileNotFoundError 的解决办法]]></title>
    <url>%2Fvscode-%E4%B8%AD%E4%BD%BF%E7%94%A8-python-%E5%BC%82%E5%B8%B8%E6%8A%A5%E9%94%99-filenotfounderror-%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[问题在vscode中使用Python,通过建立一个Python程序读取同一子目录下的txt文件, 并打印其内容. 预期结果程序读取同一个子目录中的 content.txt 文件, 然后打印其内容:12stay hungrystay foolish 实际结果通过debug, 提示如下错误:1FileNotFoundError: [Errno 2] No such file or directory: &apos;content.txt&apos; 错误分析vscode在进行debug时,使用的路径并不是当前python文件所在的目录,而是固定为项目文件夹的根目录.所以当程序试图从根目录寻找此文件时,自然会报错.于是我进一步尝试将文本文件移动至项目的根目录,错误消失.所以,解决问题的关键就是修改vscode在进行debug时使用的目录,使其自动的指向当前python文件所在目录. 解决方案初步思路是通过在 VSCode 的 Setting 中或者 debug 的配置文件中进行配置，来解决这个问题。通过 Google 后，我在 StackOverflow 上找到了具体解决方案。 参考链接: Stack Overflow - VSCode — how to set working directory for debug Stack Overflow - vscode working directory when debugging python 解决方式点击vscode侧边的调试按钮,在出现的侧栏顶端找到设置按钮(图中齿轮图标), 点击打开 launch.json 文件, 在文件中找到当前所用调试的方式, 添加cwd配置 &quot;cwd&quot;: &quot;&quot;. (我这里使用的是 Python: Terminal (integrated)) 添加完成后, 在此debug程序, 发现错误消失. 补充每次打开一个新的项目文件夹时, 都需要重新在launch.json文件中重新配置参数.]]></content>
      <categories>
        <category>Visual Studio Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>FileNotFoundError</tag>
        <tag>cwd</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些值得推荐的内容]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E6%8E%A8%E8%8D%90%E7%9A%84%E5%86%85%E5%AE%B9.html</url>
    <content type="text"><![CDATA[macOS ibuick - macOS 与 external GPU (eGPU) 非常详细的关于 macOS 下 外置显卡 (eGPU) 的设置，使用以及注意事项 的文章。]]></content>
      <tags>
        <tag>macOS</tag>
        <tag>推荐</tag>
        <tag>egpu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 上使用 Visual Studio Code 进行 Python 开发]]></title>
    <url>%2Fmac-%E4%B8%8A%E4%BD%BF%E7%94%A8-visual-studio-code-%E8%BF%9B%E8%A1%8C-python-%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[在Visual Studio Code 的官方网站中，已经有在 VSCode 上使用 Python 的详细配置了， 链接：Python in Visual Studio Code{:target=”_blank”} Python 的安装 (macOS)检查已安装的 Python 版本 检查是否安装了python2 12345$ pythonPython 2.7.15 (default, Jun 17 2018, 12:46:58) [GCC 4.2.1 Compatible Apple LLVM 9.1.0 (clang-902.0.39.2)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 检查是否安装了python3 12345$ python3Python 3.6.6 (v3.6.6:4cf1f54eb7, Jun 26 2018, 19:50:54) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 如果得到以上输出，则表示对应的版本已安装。 使用 Homebrew 来安装 Python3 安装Homebrew Homebrew依赖于Apple包Xcode，需要先进行安装。出现的对话框点OK即可。 1$ xcode-select --install 安装Homebrew： 1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 确认Homebrew安装正确 1$ brew doctor 安装Python3 1$ brew install python3 确认安装版本 12$ python3 --versionPython 3.6.6 VSCode 的配置安装VSCode的Python扩展插件 点击图片下的链接可以前往安装，直接点击Install安装即可。或者也可以直接在VSCode的扩展栏（Shift + Command + X）中搜索Python，安装下载量最高的那个。安装完成后，就可以使用VSCode编辑python代码了，按F5即可进行debug。 设置调试使用的 Python 版本Mac上自带的 Python 版本为 2.7.x，VSCode 的调试（Python:Terminal(intergrated）)默认会使用系统自带的 Python 版本。而如果我们另外安装了 Python3，希望用 Python3 进行调试的时候，就需要修改一下 VSCode 的设置了。 设置步骤: 打开VSCode用户设置（Code - 首选项 - 设置） 输入&quot;python.pythonPath&quot;:&quot;python3&quot;, 以下两个插件需要预先安装pip 配置yapf yapf简介 yapf{:target=”_blank”}是一个源代码格式化工具，可以辅助我们进行代码的格式化，安装完成后，通过快捷键 Shift + Alt + F 执行代码的格式化。 安装步骤 打开命令行，输入 pip install yapf 安装成功后， 打开VSCode用户设置（Code - 首选项 - 设置） 在setting.json文件中， 输入&quot;python.formatting.provider&quot;: &quot;yapf&quot;, yapf使用技巧 设置 代码段禁用自动格式化 通过 # yapf: disable 以及 # yapf: enable， 将不需要调整格式的代码段包括其中，即可在某些代码段禁用自动格式化。 123# yapf: disable# 这里的代码不会被自动调整格式# yapf: enable 2. 更多yafp用法参考 在终端中输入：`$ yapf -h`，查看相关帮助。 配置flake8 flake8 简介 Flake8{:target=”_blank”}包装了下列工具： PyFlakes：静态检查Python代码逻辑错误的工具。 pep8： 静态检查PEP 8编码风格的工具。 Ned Batchelder’s McCabe script：静态分析Python代码复杂度的工具。通过flake8可以帮助我们避免以及查找错误，并规范格式。 安装步骤： 打开命令行，输入 pip install flake8 打开VSCode用户设置（Code - 首选项 - 设置） 在setting.json文件中， 输入&quot;python.linting.flake8Enabled&quot;:true, flake8 的一些配置： 如果我们的使用习惯和flake8的默认设定有冲突，可以对flake8进行配置。 在控制台中，输入 flake8 --help， 会显示flake8可以设置的参数。我们可以在VSCode的Setting中对flake8的这些参数进行设置。 在用户设置中添加 &quot;python.linting.flake8Args&quot;: [], 这条设置，并在其中添加需要修改的条目即可。 调整flake8单行代码长度的检测： 12// 单行代码最大长度改为300&quot;python.linting.flake8Args&quot;: [&quot;--max-line-length=300&quot;] VSCode 的其他设置 设置代码长度 12// 80，120 表示分别在80和120字符处显示一条辅助线，可以进行设置和调整。&quot;editor.rulers&quot;: [80,120] 参考 post-image: pixiv-id-6675416{:target=”_blank”} vscode 编写python如何禁止 flake8 提示 line too long{:target=”_blank”} 《Python编程：从入门到实践》{:target=”_blank”}]]></content>
      <categories>
        <category>Visual Studio Code</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Visual Studio Code</tag>
        <tag>Python安装&amp;配置</tag>
        <tag>yapf</tag>
        <tag>flake8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇Blog]]></title>
    <url>%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog.html</url>
    <content type="text"><![CDATA[Hey 这是我的第一篇博客. 从很早以前就希望可以有一个自己的个人博客, 但是由于种种原因, 一直到现在才付诸实施.希望自己可以一直坚持下去, 不断改进自己的博客, 与它一起成长.同时也希望我分享的内容, 能够帮到此刻正在看我博客的你.]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
