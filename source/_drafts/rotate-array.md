---
title: LeetCode-189. 旋转数组 | Rotate Array
data: 
top: 
comments: false
categories:
    - LeetCode
tags:
    - LeetCode
    - Python
    - Easy
---
> [题目链接](https://leetcode-cn.com/problems/rotate-array/description/)

## 题目
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

**示例：**
```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

说明:
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的原地算法。

## 解答

### 分析 & 思路
题目为把数组向右移动k个位置，其实就相当于将数组的最后一个元素移动至数组首位，循环k次。同时由于题中没有给定k和nums的长度，所以要考虑到这两者长度的问题以及关系：
- k = 0
- len(nums) <=1
- k > len(nums)
当 k 大于数组的长度时，如果直接循环，多循环的几轮是没有意义的，所以只需要循环 k%len(nums) 次即可。 同时，由于是不断的将数组末端的值放至数组前端，所以也就是将数组末尾的k个值拼接到剩余元素的前端。

通过以上思路，有两种方式：
1. 循环
2. 利用切片进行修改


### 方式一(循环)：

### 方式二(切片)：

```python
class Solution:
    def rotate(self, nums, k):
        length = len(nums)
        i = k % length
        nums[:] = nums[-i:] + nums[:-i]
```


## 扩展

### 解题中出现的问题：

> 当前的问题：
> 1. 无法正常对函数外部的nums进行修改
> 2. 最开始的代码未考虑 `k>len(nums)` 的这种情况，在测试时出现错误
> 3. 对列表切片的理解

#### 1. 关于list的值传递和地址传递
* 传值:

	```python
	listA[:] = listB
	listA[:] = listB[:]
	listA[:] = [2,3,3]
	```
* 传地址：
	```python
	listA = listB
	listA = listB[:]
	listA = [2,3,3]
	```

> 由于自己的生疏，错误的使用了传地址的方式给list赋值，导致修改了list所指向的内存，而不是修改了原本所指内存的内容，所以出现了无法修改函数外传入的数组 这样的问题。

#### 2. 关于 k > len(nums) 情况的处理：
* 开始考虑过：
	```python
	if len(nums) < k:
		k = k - len(nums)
	```
	这样存在问题: k 可能会大于 length 很多倍。
	> 经过自己的分析，这种方式并不妥当。但是在解题过程中使用后，提交答案通过，且在给出的案例中也有相似的操作。所以这个有比较进一步分析一下原因。
	
* 通过循环解决：
	就是上面的判断丢在循环里。同时加上了 `if k != 0 and len(nums) > 1 and k != len(nums)` 这样的判断。
	>这种方式可行，但是并不是最优解。
* 直接利用求余运算`%`解决：
	```
	length = len(nums)
        i = k % length
	```
	
#### 3. 关于切片的复习：
这个放在知识点延展中来说。

### 知识点：

#### 1. 列表切片
首先有几个可以参考：
1. 关于回文素数的题目，生成回文数
2. [廖雪峰Python教程](https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868196352269f28f1f00aee485ea27e3c4e47f12bc7000)
总结归纳：

#### 2. Python的值传递&地址传递

#### 3. 关于解决方式第2点中的进一步分析：

## 思考